#!/usr/bin/python3

from abc import ABC
import csv
import itertools
import math
import operator
import sys
import colour
from PIL import Image, ImageDraw, ImageFont

import colour
from colour.notation import munsell as cnm
import munsellkit as mkit


# Column headers from UEF tables
s_colnames = [
    'h', 'V', 'C'
]

c_colnames = [
    'x', 'y', 'z', 'X', 'Y', 'Z',
    'R', 'G', 'B', 'L*', 'a*', 'b*',
    'u', 'v', 'u*', 'v*'
]

munsell_colnames = [
    f'{wavelength}' for wavelength in range(400, 700+5, 5)
]

# Gamma correction for UEF data (see munsellpageaotf.m)
gamma = 0.5


# Page (color wheel) order
ORDERED_HUES = [
    'N',
    '2.5R',
    '5R',
    '7.5R',
    '10R',
    '2.5YR',
    '5YR',
    '7.5YR',
    '10YR',
    '2.5Y',
    '5Y',
    '7.5Y',
    '10Y',
    '2.5GY',
    '5GY',
    '7.5GY',
    '10GY',
    '2.5G',
    '5G',
    '7.5G',
    '10G',
    '2.5BG',
    '5BG',
    '7.5BG',
    '10BG',
    '2.5B',
    '5B',
    '7.5B',
    '10B',
    '2.5PB',
    '5PB',
    '7.5PB',
    '10PB',
    '2.5P',
    '5P',
    '7.5P',
    '10P',
    '2.5RP',
    '5RP',
    '7.5RP',
    '10RP'
]


def cast(row, filter):
    parsed_row = dict()
    for k, v in row.items():
        parsed_row[k] = filter(k, v)
    return parsed_row


def clamped_rgb_gamma(value):
    clamped = max(0, min(value/100.0, 1.0))
    return max(0, min(int(round(math.pow(clamped, gamma) * 255.0)), 255))


def cast_uef(row, filter):
    color = cast(row, filter)
    color['dR'], color['dG'], color['dB'] = [
        clamped_rgb_gamma(color[key]) for key in ['R', 'G', 'B']]
    return color


def rit_filter(k, v):
    if k == 'h':
        return v
    elif k == 'V':
        return 10 * int(v)
    elif k in ['file order', 'C', 'dR', 'dG', 'dB']:
        return int(v)
    else:
        return float(v)


def new_color_source(name):
    if name == 'uef':
        return UEFColorSource(name)
    if name == 'rit':
        return RITColorSource(name)
    return ScienceColorSource(name)


def draw_text_ralign(draw, xy, text, font):
    (w, h) = draw.textsize(text, font=font)
    (x, y) = xy
    draw.text((x - w, y), text, font=font, fill='#000000')




# Munsell value (*10) and dRGB value
# Data generated by munsellinterpol R package.
NEUTRALS = [
    (  5,  17 ),
    ( 10,  28 ),
    ( 15,  38 ),
    ( 20,  48 ),
    ( 25,  60 ),
    ( 30,  72 ),
    ( 35,  84 ),
    ( 40,  96 ),
    ( 45, 109 ),
    ( 50, 122 ),
    ( 55, 134 ),
    ( 60, 147 ),
    ( 65, 160 ),
    ( 70, 173 ),
    ( 75, 187 ),
    ( 80, 200 ),
    ( 85, 213 ),
    ( 90, 227 ),
    ( 95, 241 )
]

class ColorSource(ABC):
    def __init__(self, name):
        self.name = name
        self.neutral_colors = [{
            'h': 'N', 'V': v, 'C': 0,
            'dR': rgb_val, 'dG': rgb_val, 'dB': rgb_val
            } for (v, rgb_val) in NEUTRALS]

    def label(self, color):
        return self.hvc_label(color['h'], color['V'], color['C'])

    def hvc_label(self, hue, value, chroma):
        (d, m) = divmod(value, 10)
        v_str = str(d) if m == 0 else f'{d}.{m}'
        if hue == 'N':
            label = f'N {v_str}'
        else:
            label = f'{hue} {v_str}/{chroma}'
        return label

    def find_chroma(self, h, c):
        if h == 'N':
            return (0, '')
        found = next(((x, label) for (x, c_test, label)
                      in self.chroma_labels if c_test == c), None)
        return found

    def find_value(self, v):
        found = next(((y, label) for (y, v_test, label)
                      in self.value_labels if v_test == v), None)
        return found

    def location_on_page(self, color):
        h = color['h']
        v = color['V']
        c = color['C']
        found_c = self.find_chroma(h, c)
        if found_c is not None:
            (x, _) = found_c
            found_v = self.find_value(v)
            if found_v is not None:
                (y, _) = found_v
                return (x, y)
        return None

    def get_bracket_colors(self, hue, value, chroma, num):
        idx_last = len(ORDERED_HUES) - 1
        idx = ORDERED_HUES.index(hue)
        colors = []
        for offset in range(-num, num + 1):
            i = idx + offset
            if i < 1:
                i = i + idx_last
            elif i > idx_last:
                i = i - idx_last
            target_hue = ORDERED_HUES[i]
            max_chroma = self.find_highest_chroma(target_hue, value, chroma)
            colors.append({'h': target_hue, 'V': value, 'C': min(chroma, max_chroma)})
        return colors


class ScienceColorSource(ColorSource):
    def __init__(self, name):
        super(ScienceColorSource, self).__init__(name)
        self.chroma_labels = [(idx, c, label) for idx, (c, label) in enumerate([
            (2, '/2 '),
            (4, '/4 '),
            (6, '/6 '),
            (8, '/8 '),
            (10, '/10'),
            (12, '/12'),
            (14, '/14'),
            (16, '/16'),
            (18, '/18'),
        ])]
        self.value_labels = [(idx, v, label) for idx, (v, label) in enumerate([
            (25, '2.5/'),
            (30, '  3/'),
            (40, '  4/'),
            (50, '  5/'),
            (60, '  6/'),
            (70, '  7/'),
            (80, '  8/'),
            (85, '8.5/'),
            (90, '  9/')
        ])]

    def rgb(self, color):
        spec = self._to_colorlab(color['h'], color['V']/10, color['C'])
        rgb = mkit.munsell_specification_to_rgb(spec)
        return [min(255, max(0, round(v * 255))) for v in rgb]

    def find_nearest(self, hue, value, chroma):
        if hue == 'N':
            if chroma is None:
                chroma = 0
        else:
            max_chroma = self.find_highest_chroma(hue, value, chroma)
            if max_chroma < chroma:
                print(f'Maximum chroma for {hue} {value/10}/{chroma} is {max_chroma}')
                return None
        return {'h': hue, 'V': value, 'C': chroma}

    def get_hue_colors(self, hue):
        if hue == 'N':
            for value in [v[1] for v in self.value_labels]:
                yield {'h': 'N', 'V': value, 'C': 0}
        else:
            high_chroma = self.chroma_labels[-1][1]
            for value in [v[1] for v in self.value_labels]:
                max_chroma = self.find_highest_chroma(hue, value, high_chroma)
                for chroma in [c[1] for c in self.chroma_labels if c[1] <= max_chroma]:
                    yield {'h': hue, 'V': value, 'C': chroma}

    def get_chroma_colors(self, hue, value, max):
        high_chroma = self.chroma_labels[-1][1]
        max_chroma = self.find_highest_chroma(hue, value, high_chroma)
        colors = []
        for chroma in [c[1] for c in self.chroma_labels if c[1] <= max_chroma]:
            colors.append({'h': hue, 'V': value, 'C': chroma})
        return colors[-max:]

    def find_highest_chroma(self, hue, value, chroma):
        spec = self._to_colorlab(hue, value/10, chroma)
        max_chroma = cnm.maximum_chroma_from_renotation(spec[0], spec[1], spec[3])
        return max_chroma

    def _to_colorlab(self, hue, value, chroma):
        '''Returns float array of shape (4,)'''
        if hue == 'N':
            munsell_color = f'N{value}'
        else:
            munsell_color = f'{hue} {value}/{chroma}'
        return cnm.parse_munsell_colour(munsell_color)


class LegacyColorSource(ColorSource):
    def __init__(self, name):
        super(LegacyColorSource, self).__init__(name)
        self.data = self.read_data()

    def read_data(self):
        raise Exception('Must use subclass!')

    def rgb(self, color):
        return [color[key] for key in ['dR', 'dG', 'dB']]

    def find_nearest(self, hue, value, chroma):
        for color in self.data:
            if color['h'] == hue and color['V'] == value and \
                (chroma is None or color['C'] == chroma):
                return color
        return None

    def get_hue_colors(self, hue):
        return [c for c in self.data if c['h'] == hue]

    def get_chroma_colors(self, hue, value, max):
        chromas = [color for color in self.data
                   if color['h'] == hue and color['V'] == value and self.find_chroma(hue, color['C']) is not None]
        chromas.sort(key=lambda x: x['C'])
        return chromas[-max:]

    def find_highest_chroma(self, hue, value, chroma):
        highest_chroma = -2
        for color in self.data:
            if color['h'] == hue and color['V'] == value and color['C'] <= chroma and color['C'] > highest_chroma:
                highest_chroma = color['C']

        if highest_chroma < 0:
            raise Exception(f'No chroma found for {self.hvc_label(hue, value, chroma)}')
        return highest_chroma

    def print_colors(self):
        for idx, color in enumerate(self.data):
            rgb = (color['R'], color['G'], color['B'])
            r, g, b = self.rgb(color)
            hex = f'#{r:02X}{g:02X}{b:02X}'
            label = self.label(color)
            print(f'idx {idx} label {label} rgb {rgb} hex {hex}')


class UEFColorSource(LegacyColorSource):
    def __init__(self, name):
        super(UEFColorSource, self).__init__(name)
        self.chroma_labels = [(idx, c, label) for idx, (c, label) in enumerate([
            (1, '/1 '),
            (2, '/2 '),
            (4, '/4 '),
            (6, '/6 '),
            (8, '/8 '),
            (10, '/10'),
            (12, '/12'),
            (14, '/14'),
            (16, '/16')
        ])]
        self.value_labels = [(idx, v, label) for idx, (v, label) in enumerate([
            (25, '2.5/'),
            (30, '  3/'),
            (40, '  4/'),
            (50, '  5/'),
            (60, '  6/'),
            (70, '  7/'),
            (80, '  8/'),
            (85, '8.5/'),
            (90, '  9/')
        ])]

    def read_data(self):
        with open('munsell400_700_5.munsell.csv') as munsell_file:
            def filter_1(k, v): return v
            self.munsell = [cast(row, filter_1)
                            for row in csv.DictReader(munsell_file)]

        with open('munsell400_700_5.s.csv') as s_file:
            def filter_2(k, v): return int(v) if k in ['V', 'C'] else v
            s = [cast(row, filter_2) for row in csv.DictReader(s_file)]

        with open('munsell400_700_5.c.csv') as c_file:
            def filter_3(k, v): return float(v)
            c = [cast_uef(row, filter_3) for row in csv.DictReader(c_file)]

        data = []
        for i in range(0, len(s)):
            s_row = s[i]
            c_row = c[i]
            print(f'{i}: s {s_row} c {c_row}')
            s_row.update(c_row)
            data.append(s_row)
        return self.neutral_colors + data


class RITColorSource(LegacyColorSource):
    def __init__(self, name):
        super(RITColorSource, self).__init__(name)
        self.chroma_labels = [(idx, c, label) for idx, (c, label) in enumerate([
            (2, '/2 '),
            (4, '/4 '),
            (6, '/6 '),
            (8, '/8 '),
            (10, '/10'),
            (12, '/12'),
            (14, '/14'),
            (16, '/16'),
            (18, '/18'),
            (20, '/20')
        ])]
        self.value_labels = [(idx, v, label) for idx, (v, label) in enumerate([
            # (10, '  1/'),
            (20, '  2/'),
            (30, '  3/'),
            (40, '  4/'),
            (50, '  5/'),
            (60, '  6/'),
            (70, '  7/'),
            (80, '  8/'),
            # (85, '8.5/'),
            (90, '  9/')
        ])]

    def read_data(self):
        with open('rit_munsell.csv') as c_file:
            data = [cast(row, rit_filter) for row in csv.DictReader(c_file)]
        data.sort(key=operator.itemgetter('h', 'V', 'C'))
        return self.neutral_colors + data


# Formats an 8 1/2 by 11 inch page in the Munsell book
class MunsellPage:
    # Page parameters for PIL
    dpi = 100
    image_w = 1100
    image_h = 850

    small_font_size = 18
    large_font_size = 32
    small_font = ImageFont.truetype(
        './RobotoMono-BoldItalic.ttf', small_font_size)
    large_font = ImageFont.truetype(
        './RobotoMono-BoldItalic.ttf', large_font_size)

    patch_x0 = 100
    value_label_x0 = patch_x0 - 50
    patch_w = 72
    patch_w_stride = patch_w + 12

    patch_y0 = image_h - 50
    chroma_label_y0 = patch_y0 + 15
    patch_h = 72
    patch_h_stride = patch_h + 12

    def __init__(self, source, hue=None):
        self.source = source
        self.patch_num = 1
        self.hue = hue
        if hue is None:
            self.page_num = 1
        else:
            self.page_num = ORDERED_HUES.index(hue) + 1
        self.init_image()

    def init_image(self):
        self.img = Image.new(
            'RGB', (self.image_w, self.image_h), color='white')
        self.draw = ImageDraw.Draw(self.img)

        x0 = self.patch_x0 + ((len(self.source.chroma_labels) + 1) * self.patch_w_stride)
        y0 = self.patch_y0 - (len(self.source.value_labels) * self.patch_h_stride)
        draw_text_ralign(self.draw, (x0, y0), self.hue, self.large_font)
        draw_text_ralign(self.draw, (x0, y0 + 40), f'p. {self.page_num}', self.small_font)

        for (y, v, label) in self.source.value_labels:
            y0 = self.patch_y0 - self.patch_h - (y * self.patch_h_stride)
            self.draw.text((self.value_label_x0, y0),
                           label, font=self.small_font, fill='#000000', align='left')

        if self.hue != 'N':
            for (x, c, label) in self.source.chroma_labels:
                x0 = self.patch_x0 + (x * self.patch_w_stride)
                self.draw.text((x0, self.chroma_label_y0),
                               label, font=self.small_font, fill='#000000', align='left')

    def add_patch(self, color):
        location = self.source.location_on_page(color)
        if location:
            (x, y) = location
            x0 = self.patch_x0 + (x * self.patch_w_stride)
            y0 = self.patch_y0 - (y * self.patch_h_stride)
            x1 = x0 + self.patch_w
            y1 = y0 - self.patch_h
            xy = [x0, y0, x1, y1]
            r, g, b = self.source.rgb(color)
            fill = f'#{r:02X}{g:02X}{b:02X}'
            self.draw.rectangle(xy, fill=fill)
        else:
            label = self.source.label(color)
            print(f'Patch {label} will not be printed')

    def print(self):
        file_name = f'{self.source.name}_{self.page_num:02d}_{self.hue}.png'
        self.img.save(file_name, dpi=(self.dpi, self.dpi))

    def location_by_patch_num(self, color):
        x = ((self.patch_num - 1) % 10) * 2
        y = (self.patch_num - 1) // 10
        self.patch_num = self.patch_num + 1
        return (x, y)


# Formats a 4 by 6 1/2 inch card of one hue and value
class MunsellCard:
    # Card parameters for PIL
    dpi = 100
    image_w = 600
    image_h = 400

    patches_per_row = 4
    patch_rows = 2
    max_patches = patch_rows * patches_per_row

    small_font_size = 14
    small_font = ImageFont.truetype(
        './RobotoMono-BoldItalic.ttf', small_font_size)

    patch_x0 = 40
    patch_w = 120
    patch_w_stride = patch_w + 12

    patch_y0 = image_h - 70
    patch_h = 120
    patch_h_stride = patch_h + 50

    def __init__(self, source, mode, color=None):
        '''mode is 'chips', 'hue' or 'chroma'.
        For mode 'chips', `color` is none.
        For mode 'hue', `color` is a full specification.
        For mode 'chroma', `color` only specifies hue and value.
        '''

        self.source = source
        self.mode = mode
        if color:
            self.hue = color['h']
            self.value = color['V']
            self.chroma = color['C']
        else:
            self.hue = None
            self.value = None
            self.chroma = None

        # More patches on N card, please
        if self.hue == 'N':
            self.patches_per_row = 5
            self.max_patches = self.patch_rows * self.patches_per_row
            self.patch_w = 92
            self.patch_w_stride = self.patch_w + 12

        self.init_image()

    def init_image(self):
        self.img = Image.new(
            'RGB', (self.image_w, self.image_h), color='white')
        self.draw = ImageDraw.Draw(self.img)

    def add_patches(self):
        if self.hue == 'N':
            colors = [color for color in self.source.neutral_colors 
                if color['V'] in [20, 30, 40, 50, 60, 70, 80, 85, 90, 95]]
            colors = colors[-self.max_patches:]
        elif self.mode == 'chroma':
            colors = self.source.get_chroma_colors(
                self.hue, self.value, self.max_patches)
        else:
            num_brackets = (self.max_patches - 1) // 2
            colors = self.source.get_bracket_colors(
                self.hue, self.value, self.chroma, num_brackets)
            # self.chroma = colors[num_brackets]['C']

        num_patches = len(colors)
        if num_patches == 0:
            print(f'No patches found for {self.hue} {self.value}')
            return False

        offset = self.max_patches - num_patches
        for idx, color in enumerate(colors):
            self.add_patch(idx + offset, color)
        return True

    def add_patch(self, idx, color, name=None):
        if idx < self.max_patches:
            (y, x) = divmod(idx, self.patches_per_row)
            y = self.patch_rows - y - 1
            x0 = self.patch_x0 + (x * self.patch_w_stride)
            y0 = self.patch_y0 - (y * self.patch_h_stride)
            x1 = x0 + self.patch_w
            y1 = y0 - self.patch_h
            xy = [x0, y0, x1, y1]
            
            r, g, b = self.source.rgb(color)
            fill = f'#{r:02X}{g:02X}{b:02X}'

            label = self.source.label(color)
            if name is None:
                label2 = fill
            else:
                label2 = label
                label = name

            label_y = y0 + 6
            label2_y = label_y + self.small_font_size + 2 
            self.draw.rectangle(xy, fill=fill)
            self.draw.text((x0, label_y), label, font=self.small_font,
                           fill='#000000', align='left')
            if label2 is not None:
                self.draw.text((x0, label2_y), label2, font=self.small_font,
                           fill='#000000', align='left')
            return True
        return False

    def print(self, page_num=1, prefix=''):
        if self.mode == 'chips':
            if prefix is None or prefix == '':
                prefix = 'chips'
            file_name = f'{prefix}_{page_num}.png'
        else:
            page_num = ORDERED_HUES.index(self.hue) + 1
            if self.mode == 'chroma':
                file_name = f'card_{self.hue}_{self.value:02d}.png'
            else:
                file_name = f'hues_{self.hue}_{self.value:02d}_{self.chroma}.png'
        self.img.save(file_name, dpi=(self.dpi, self.dpi))


# Formats a 7 inch wheel for a letter-size page
class MunsellWheel:
    # Card parameters for PIL
    dpi = 100
    image_w = 850
    image_h = 1100

    x0 = image_w / 2
    y0 = image_h / 2
    patch_w_2 = 63
    patch_r0 = 200
    patch_r1 = patch_r0 + 2 * patch_w_2
    max_patches = 10
    degrees_per_patch = 360 / max_patches

    small_font_size = 14
    small_font = ImageFont.truetype(
        './RobotoMono-BoldItalic.ttf', small_font_size)

    def __init__(self, source):
        self.source = sourceall_colorssource.data
    def init_image(self):
        self.img = Image.new(
            'RGB', (self.image_w, self.image_h), color='white')
        self.draw = ImageDraw.Draw(self.img)

    def add_patch(self, idx, color, name=None):
        if idx < self.max_patches:
            angle = (idx * self.degrees_per_patch - 90) * math.pi / 180
            c = math.cos(angle)
            s = math.sin(angle)
            x0 = self.x0 + self.patch_r0 * c + self.patch_w_2 * s
            y0 = self.y0 + self.patch_r0 * s - self.patch_w_2 * c
            x1 = self.x0 + self.patch_r1 * c + self.patch_w_2 * s
            y1 = self.y0 + self.patch_r1 * s - self.patch_w_2 * c
            x2 = self.x0 + self.patch_r1 * c - self.patch_w_2 * s
            y2 = self.y0 + self.patch_r1 * s + self.patch_w_2 * c
            x3 = self.x0 + self.patch_r0 * c - self.patch_w_2 * s
            y3 = self.y0 + self.patch_r0 * s + self.patch_w_2 * c
            r, g, b = self.source.rgb(color)
            fill = f'#{r:02X}{g:02X}{b:02X}'
            self.draw.polygon([(x0, y0), (x1, y1), (x2, y2), (x3, y3)], fill=fill)
            return True

        return False

    def print(self, prefix=''):
        if prefix is None or prefix == '':
            prefix = 'wheel'
        file_name = f'{prefix}.png'
        self.img.save(file_name, dpi=(self.dpi, self.dpi))
        

class Munsell:
    def __init__(self, source_name='rit'):
        self.source = new_color_source(source_name)

    def print_card(self, mode, color):
        card = MunsellCard(self.source, mode, color)
        card.add_patches()
        card.print()

    def print_all_cards(self):
        for hue in ORDERED_HUES:
            if hue == 'N':
                card = MunsellCard(self.source, 'chroma', {
                    'h': 'N', 'V': None, 'C': None})
                card.add_patches()
                card.print()
            else:
                for value in range(20, 100, 10):
                    card = MunsellCard(self.source, 'chroma', {
                        'h': hue, 'V': value, 'C': None})
                    card.add_patches()
                    card.print()

    def print_book(self):
        current_page = None
        for hue in ORDERED_HUES:
            if current_page is not None:
                current_page.print()
            current_page = MunsellPage(self.source, hue)
            for color in self.source.get_hue_colors(hue):
                current_page.add_patch(color)
        if current_page is not None:
            current_page.print()

    def print_page(self, hue):
        page = MunsellPage(self.source, hue)
        for color in self.source.get_hue_colors(hue):
            try:
                page.add_patch(color)
            except ValueError:
                print(f'Error printing patch: {color}')
        page.print()

    def print_chips(self, colors, prefix):
        card = MunsellCard(self.source, 'chips')
        page_num = 1
        idx = 0
        for hvc in colors:
            color = card.source.find_nearest(hvc['h'], hvc['V'], hvc['C'])
            if not color:
                print(f"No match for {hvc['spec']}")
                continue
            if card.add_patch(idx, color, name=hvc['name']):
                idx = idx + 1
            else:
                card.print(page_num, prefix)
                page_num = page_num + 1
                idx = 0
                card.init_image()
                if card.add_patch(0, color, name=hvc['name']):
                    idx = 1
        if idx > 0:
            card.print(page_num, prefix)

    def print_wheel(self, colors, prefix):
        wheel = MunsellWheel(self.source)
        idx = 0
        for hvc in colors:
            color = wheel.source.find_nearest(hvc['h'], hvc['V'], hvc['C'])
            if not color:
                print(f"No match for {hvc['spec']}")
                continue
            if wheel.add_patch(idx, color, name=hvc['name']):
                idx = idx + 1
            if idx == 10:
                break
        if idx > 0:
            wheel.print(prefix)

def parse_neutral(spec):
    m = re.match(
        r'N\s*([.0-9]+)', spec)
    if m:
        hue = 'N'
        value = int(round(float(m.group(1)) * 10.0))
        return {'spec': spec, 'h': hue, 'V': value, 'C': None}
    return None

def parse_hue(spec):
    m = re.match('N', spec)
    if m:
        return m.group(1)
    m = re.match(
        r'([.0-9]+)\s*([BGPRY]{1,2})', spec)
    if m:
        return m.group(1) + m.group(2)
    return None

def parse_hue_value(spec):
    m = re.match(
        r'([.0-9]+)\s*([BGPRY]{1,2})\s*([.0-9]+)', spec)
    if m:
        hue = m.group(1) + m.group(2)
        value = int(round(float(m.group(3)) * 10.0))
        return {'spec': spec, 'h': hue, 'V': value, 'C': None}
    return None

def parse_hue_value_chroma(spec):
    m = re.match(
        r'([.0-9]+)\s*([BGPRY]{1,2})\s*([.0-9]+)[ /]+([0-9]+)', spec)
    if m:
        hue = m.group(1) + m.group(2)
        value = int(round(float(m.group(3)) * 10.0))
        chroma = int(m.group(4))
        return {'spec': spec, 'h': hue, 'V': value, 'C': chroma}
    return None

def parse_color(arg):
    arg = arg.strip()
    if arg == '' or arg[0] == '#':
        return None

    if ':' in arg:
        name, spec = arg.split(':', 1)
        name = name.strip()
        if name == '':
            name = None
    else:
        name = None
        spec = arg

    parsed = parse_neutral(spec)
    if parsed is None:
        parsed = parse_hue_value_chroma(spec)
    if parsed:
        parsed['name'] = name
        return parsed

    print(f'Notation {spec} could not be parsed')
    return None


if __name__ == '__main__':
    import argparse
    import re

    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--source', help='data source: "sci", "rit" or "uef"', choices=['sci', 'rit', 'uef'], default='sci')
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        '--book', help='print all colors in book format', action='store_true')
    group.add_argument(
        '--page', help='print a page from the book for a specific hue, like "10YR"', metavar='HUE')
    group.add_argument(
        '--card', help='print a card for a specific hue and value, like "10YR8"; or "N" to print a card of neutrals; or "all" to output all cards')
    group.add_argument(
        '--hues', help='print a card bracketing the colors near a given color, like "10YR8/12"', metavar='COLOR')
    group.add_argument(
        '--chips', help='print a page of chips, reading from a list of arguments', action='append', nargs='+', metavar='COLOR')
    group.add_argument(
        '--wheel', help='print 10 colors in a wheel', action='append', nargs='+', metavar='COLOR')
    parser.add_argument(
        '--prefix', help='prefix for chip file names', default='chips'
    )
    args = parser.parse_args()

    if args.book:
        Munsell(args.source).print_book()
    elif args.page is not None:
        hue = parse_hue(args.page)
        if hue:
            Munsell(args.source).print_page(hue)
        else:
            parser.error(f'Cannot parse hue in --page {args.page}')
    elif args.hues is not None:
        color = parse_color(args.hues)
        if color:
            Munsell(args.source).print_card('hue', color)
        else:
            parser.error(f'Cannot parse color in --hues {args.hues}')
    elif args.chips is not None:
        colors = [parse_color(arg)
                  for arg in itertools.chain.from_iterable(args.chips)]
        colors = [color for color in colors if color]
        if len(colors) > 0:
            Munsell(args.source).print_chips(colors, args.prefix)
        else:
            parser.error(f'No colors were parsed in --chips {args.chips}')
    elif args.wheel is not None:
        colors = [parse_color(arg)
                  for arg in itertools.chain.from_iterable(args.wheel)]
        colors = [color for color in colors if color]
        if len(colors) > 0:
            Munsell(args.source).print_wheel(colors, args.prefix) 
        else:
            parser.error(f'No colors were parsed in --wheel {args.wheel}')
    elif args.card is None:
        parser.error(
            'an output type is required, either --book, --card, --chips, or --hues')
    elif args.card == 'all':
        Munsell(args.source).print_all_cards()
    elif args.card == 'N':
        Munsell(args.source).print_card(
            'chroma', {'h': 'N', 'V': 0, 'C': None})
    else:
        parsed = parse_hue_value(args.card)
        if parsed:
            Munsell(args.source).print_card('chroma', parsed)
        else:
            parser.error(f'No hue/value was parsed in --card {args.card}')
